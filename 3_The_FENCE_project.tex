\section{The FENCE project}
\label{sec:The_FENCE_project}
FENCE is an object oriented \textit{PHP}~\cite{php} framework designed for the development of web applications according to the model–view–controller (MVC) architectural pattern. Since FENCE promotes reuse, similar features are implemented from predefined software components. Therefore, it speeds up the development process and reduces maintenance costs. The FENCE software development process encompasses Software Engineering techniques in order to guarantee Software Quality. Requirements are gathered and documented prior to the solution design. This way, developers are able to propose broad solutions that can benefit the whole project. One example is the Models, Builders and Factories design (MBF), which compose a wrapper used to connect to the Database and efficiently build structured objects. This group of classes is used throughout all FENCE systems, whenever is needed to express Database information.

\subsection{FENCE main classes}
\label{sec:FENCE_main_classes}
The FENCE framework is composed by several classes that are extensible program-code-template for creating objects, providing initial values and implementations of functions or methods. Any new class can be codified and added to the framework, enlarging its scope, to then be reused in different systems. One example is the GlanceSearch class that provides methods to create search interfaces by adding only some lines of code and the specification of the search and results attributes through a configuration file. The SuperSearch offers an advanced search interface, where the user can build logic queries with AND and OR operators. The User class supports the access control of the interfaces. The Mailer class can be used to send automatic emails. Form inputs can be easily added using classes like TextInput, DateInput or MemberInput, which provides a selection box with the list of all members of an experiment.
                    
The FENCE Workflow class is another example of feature that can be inherited by the systems that are implemented using the framework. That can be applied to codify any process involving states and actions triggered while moving from a state to another. This is largely used by the ATLAS Analysis systems, which are organised in phases, each one divided into several steps. Each of those steps can record metadata in the ATLAS Database, trigger an \textit{egroup}~\cite{egroups} creation or update, trigger a \textit{Gitlab}~\cite{gitlab} repository creation or update, send automatic emails and other tasks. 


\subsection{Configuration files in FENCE}
\label{sec:Configuration_files_in_FENCE}

The FENCE framework proposal is based on configuration files that deploy content to be rendered on interfaces. The main goal of this design pattern is to simplify many aspects of web systems requirements. As\textit{ JSON} files are structured objects, developers can easily define a group of properties within specific contexts. For instance, it is possible to set up which groups of users can have access to a certain interface.
Another benefit of using configuration files is that major classes, that have several arguments and environment parameters, can be instantiated in a cleaner way, with just a configuration file path as argument. With that, developers feel encouraged to develop more generic and robust features, since they can be easily reused it in the future.

Along with the configuration file concept, additional utils were developed to guarantee the feasibility of this idea. One of these tools is the class JReader, which parses a JSON input file, validates it and provides the JSON data to PHP code. Another one is the FENCE Content class, which gets some default information from configuration file to handle common interface needs, such as access control, constants and rendering outline formats.

Most of the time, when a new interface is created using FENCE, the class that generates the particular content of this page is extending the Content class. At the same time, the Content class, which has a configuration file path as argument, uses JReader to validate and access the JSON properties.
